# Services Refactoris√©s - Guide de Migration

Ce document d√©crit le refactoring des services du backend multi-LLM et explique comment migrer vers les nouvelles versions.

## üéØ Objectifs du Refactoring

Le refactoring vise √† corriger les nombreuses fonctionnalit√©s manquantes dans `app/services/search_service.py` et les autres services, tout en gardant l'esprit du code original. Les am√©liorations incluent :

- **Architecture modulaire** : S√©paration des responsabilit√©s
- **Gestion d'erreurs robuste** : Exceptions structur√©es et gestion uniforme
- **Performance** : Mise en cache et optimisations
- **Observabilit√©** : Logs, m√©triques et health checks
- **Maintenabilit√©** : Code plus propre et testable

## üìÅ Structure des Nouveaux Services

```
app/services/
‚îú‚îÄ‚îÄ base_service.py                    # Classes de base communes
‚îú‚îÄ‚îÄ config_service.py                  # Gestion centralis√©e de la configuration
‚îú‚îÄ‚îÄ search_components.py               # Composants modulaires de recherche
‚îú‚îÄ‚îÄ search_service_refactored.py       # Service de recherche refactoris√©
‚îú‚îÄ‚îÄ embedding_service_refactored.py    # Service d'embeddings refactoris√©
‚îú‚îÄ‚îÄ document_service_refactored.py     # Service de documents refactoris√©
‚îú‚îÄ‚îÄ generate_service_refactored.py     # Service de g√©n√©ration refactoris√©
‚îî‚îÄ‚îÄ service_compatibility.py           # Couche de compatibilit√© pour migration progressive
```

## üîß Services Refactoris√©s

### 1. ConfigService - Gestion Centralis√©e de la Configuration

**Fichier** : `config_service.py`

**Fonctionnalit√©s** :
- Centralisation de toutes les variables d'environnement
- Configuration par sections (LLM, Search, Qdrant)
- Mise √† jour dynamique des param√®tres
- Validation automatique

**Exemple d'utilisation** :
```python
from app.services.config_service import config_service

# Acc√®s √† la configuration
llm_model = config_service.llm.model
search_limit = config_service.search.default_limit

# Mise √† jour dynamique
config_service.update_config("llm", "temperature", 0.7)
```

### 2. BaseService - Classes de Base Communes

**Fichier** : `base_service.py`

**Fonctionnalit√©s** :
- Gestion d'erreurs standardis√©e
- Validation d'entr√©es
- Logging structur√©
- Pattern de service avec cache (CacheableService)
- Health checks

**Classes disponibles** :
- `BaseService` : Service de base avec gestion d'erreurs
- `CacheableService` : Service avec cache automatique
- `ServiceResponse` : Format de r√©ponse standardis√©
- `ServiceError`, `ValidationError`, `ExternalServiceError` : Exceptions typ√©es

### 3. SearchService Refactoris√©

**Fichier** : `search_service_refactored.py`

**Am√©liorations** :
- Architecture modulaire avec composants sp√©cialis√©s
- Cache automatique des r√©sultats (30 minutes)
- Gestion d'erreurs robuste
- Health checks complets
- Configuration flexible

**Composants modulaires** (`search_components.py`) :
- `DocumentProcessor` : Extraction de texte et traitement de documents
- `KeywordBooster` : Boost des scores bas√© sur les mots-cl√©s
- `LLMReranker` : R√©ordonnancement des r√©sultats par LLM
- `SearchResultFilter` : Filtrage des r√©sultats par m√©tadonn√©es

**Exemple d'utilisation** :
```python
from app.services.search_service_refactored import search_service_refactored

# Recherche hybride
result = search_service_refactored.hybrid_search(
    query="recherche de test",
    limit=10,
    use_llm_reranking=True,
    boost_keywords=True
)

# Health check
health = search_service_refactored.health_check()
```

### 4. EmbeddingService Refactoris√©

**Fichier** : `embedding_service_refactored.py`

**Am√©liorations** :
- Cache de 2 heures pour √©viter les recalculs
- Traitement par lots pour grandes collections
- Gestion de timeout et retry
- Validation robuste des embeddings
- M√©triques de performance

**Nouvelles fonctionnalit√©s** :
```python
from app.services.embedding_service_refactored import embedding_service_refactored

# Embedding simple avec cache
embedding = embedding_service_refactored.get_embedding("texte")

# Traitement par lots
embeddings = embedding_service_refactored.get_embeddings_batch(
    texts=["texte1", "texte2", "texte3"],
    batch_size=10
)

# Dimension du mod√®le
dimension = embedding_service_refactored.get_embedding_dimension()
```

### 5. DocumentService Refactoris√©

**Fichier** : `document_service_refactored.py`

**Am√©liorations** :
- Pagination efficace pour le listage
- Recherche et filtrage avanc√©s
- Statistiques de collection
- Validation compl√®te des entr√©es
- Gestion d'erreurs contextuelle

**Nouvelles fonctionnalit√©s** :
```python
from app.services.document_service_refactored import document_service_refactored

# Listage avec pagination
result = document_service_refactored.list_documents(limit=100, offset=0)

# Recherche par crit√®res
search_result = document_service_refactored.search_documents({
    "file_type": "pdf",
    "upload_date": "2024"
})

# Statistiques
stats = document_service_refactored.get_document_statistics()
```

### 6. GenerateService Refactoris√©

**Fichier** : `generate_service_refactored.py`

**Am√©liorations** :
- Orchestration am√©lior√©e du workflow
- Validation compl√®te des requ√™tes
- Monitoring des d√©pendances
- Gestion d'erreurs contextuelle
- Configuration flexible

**Nouvelles fonctionnalit√©s** :
```python
from app.services.generate_service_refactored import generate_service_refactored

# Validation de requ√™te
validation = generate_service_refactored.validate_generate_request({
    "current_message": "Bonjour",
    "additional_info": "Test"
})

# G√©n√©ration avec gestion d'erreurs
result = generate_service_refactored.generate_response(
    discussion_id=None,
    current_message="Bonjour",
    settings_id="custom-settings"
)
```

## üîÑ Migration Progressive

### Couche de Compatibilit√©

**Fichier** : `service_compatibility.py`

La couche de compatibilit√© permet une migration progressive sans casser l'API existante :

```python
from app.services.service_compatibility import migration_manager

# Basculer vers les services refactoris√©s
migration_manager.migrate_service('search', True)
migration_manager.migrate_service('embedding', True)

# V√©rifier le statut de migration
status = migration_manager.get_migration_status()

# Utiliser les services via les wrappers de compatibilit√©
from app.services.service_compatibility import (
    search_service_compat,
    embedding_service_compat
)

# L'API reste identique, mais utilise les services refactoris√©s
result = search_service_compat.hybrid_search("test")
embedding = embedding_service_compat.get_embedding("text")
```

### Endpoints API v2

**Fichier** : `app/api/refactored_endpoints.py`

Nouveaux endpoints qui utilisent directement les services refactoris√©s :

```
GET    /api/v2/health                    # √âtat de sant√© global
POST   /api/v2/search/hybrid             # Recherche hybride
POST   /api/v2/embeddings/batch          # Embeddings par lot
GET    /api/v2/documents/stats           # Statistiques des documents
POST   /api/v2/migration/toggle-service  # Bascule de service
```

## üß™ Tests et Validation

### Script de Test

**Fichier** : `test_refactored_services.py`

Script de d√©monstration pour tester tous les services refactoris√©s :

```bash
python test_refactored_services.py
```

Le script teste :
- Configuration centralis√©e
- Services d'embeddings avec cache
- Gestion des documents avec pagination
- Recherche hybride avec composants modulaires
- Service de g√©n√©ration avec validation
- Couche de compatibilit√©
- Comparaison de performance

### Health Checks

Chaque service fournit des health checks d√©taill√©s :

```python
# Health check global
from app.services.service_compatibility import get_service_health_summary
health = get_service_health_summary()

# Health check par service
search_health = search_service_refactored.health_check()
embedding_health = embedding_service_refactored.health_check()
```

## üìä M√©triques et Monitoring

### Logs Structur√©s

Tous les services utilisent un logging structur√© avec niveaux appropri√©s :

```python
# Les logs incluent automatiquement :
# - Service name
# - Log level
# - Timestamp
# - Context information
```

### Statistiques de Performance

- **Cache hit/miss ratios** pour les embeddings et recherche
- **Temps de r√©ponse** par op√©ration
- **Taux d'erreur** par service
- **Utilisation m√©moire** du cache

### M√©triques de Sant√©

- **Disponibilit√©** des services externes (LLM, Qdrant)
- **Latence** des appels API
- **√âtat** des d√©pendances
- **Capacit√©** de traitement

## üöÄ Plan de D√©ploiement

### Phase 1 : D√©ploiement des Services Refactoris√©s ‚úÖ
- [x] D√©ployer les nouveaux services en parall√®le
- [x] Activer la couche de compatibilit√©
- [x] Tester avec les endpoints v2

### Phase 2 : Migration Progressive
- [ ] Basculer les services un par un
- [ ] Monitorer les performances
- [ ] Valider la compatibilit√©

### Phase 3 : Nettoyage
- [ ] Supprimer les anciens services
- [ ] Mettre √† jour la documentation
- [ ] Optimiser les performances

## üîß Configuration

### Variables d'Environnement

Les nouveaux services utilisent des variables d'environnement pour la configuration :

```env
# LLM Configuration
LLM_BASE_URL=http://host.docker.internal:11434
LLM_MODEL=llama3.1:8b
LLM_TEMPERATURE=0.1
LLM_MAX_TOKENS=1024
LLM_TIMEOUT=30

# Search Configuration
DEFAULT_COLLECTION=documents
DEFAULT_SEARCH_LIMIT=10
MAX_DOCUMENT_LENGTH=2000
KEYWORD_BOOST_MAX=0.4
LLM_SCORE_WEIGHT=0.6

# Qdrant Configuration
QDRANT_HOST=localhost
QDRANT_PORT=6333
QDRANT_TIMEOUT=30
```

## üõ†Ô∏è D√©veloppement et Extension

### Ajouter un Nouveau Service

1. H√©riter de `BaseService` ou `CacheableService`
2. Impl√©menter la m√©thode `health_check()`
3. Utiliser les patterns de gestion d'erreurs
4. Ajouter des logs structur√©s

```python
from app.services.base_service import BaseService, LogLevel, ServiceResponse

class MonNouveauService(BaseService):
    def __init__(self):
        super().__init__("MonNouveauService")
    
    def ma_methode(self, param: str) -> ServiceResponse:
        def operation():
            # Logique m√©tier
            return {"result": "success"}
        
        return self.safe_execute(operation, "Erreur dans ma_methode")
    
    def health_check(self) -> ServiceResponse:
        # V√©rifications de sant√©
        return ServiceResponse.success_response({"status": "healthy"})
```

### Ajouter des M√©triques

Les services supportent l'ajout de m√©triques personnalis√©es via le syst√®me de logging structur√©.

## üìö Documentation API

La documentation compl√®te des endpoints est disponible via FastAPI :
- `/docs` - Documentation Swagger
- `/redoc` - Documentation ReDoc

## ü§ù Contribution

Pour contribuer aux services refactoris√©s :

1. Respecter l'architecture modulaire
2. Utiliser les classes de base communes
3. Ajouter des tests appropri√©s
4. Documenter les nouvelles fonctionnalit√©s
5. Maintenir la compatibilit√© descendante

## üìû Support

Pour toute question sur la migration ou les services refactoris√©s, consulter :
- Cette documentation
- Les commentaires dans le code
- Les tests de d√©monstration
- Les health checks pour diagnostiquer les probl√®mes